<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>craeft: Cr&#230;ft</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">craeft
   </div>
   <div id="projectbrief">A new systems programming language.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Cr&amp;#230;ft </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a compiler for a new systems programming language, written for Caltech CS 81 with Donnie Pinkston as project mentor. The language, Cr&amp;#230;ft, is a strongly statically typed, imperative, low-level programming language with support for generic programming inspired by C and Rust.</p>
<p>Internal documentation for the compiler can be found <a href="http://iankuehne.com/craeft">here</a>.</p>
<h1>Language </h1>
<p>Cr&amp;#230;ft is a systems programming language based on:</p><ul>
<li>Low-level access to the hardware. A competent programmer should understand how their code is executed on the processor. In practice, this means that memory is manually managed, and the programmer can make unlimited use of pointers.</li>
<li>Low-cost abstractions. The programmer should not have to balance performance with maintainable code.</li>
<li>Strong static typing. The type system should be expressive, and the compiler should only allow it to be circumvented with explicit annotations.</li>
</ul>
<h2>Syntax </h2>
<p>The syntax is simple, and largely familiar to any C programmer. Roughly, in EBNF:</p>
<div class="fragment"><div class="line">identifier: [a-z|non-ascii][a-zA-Z0-9_|non-ascii]*</div><div class="line"></div><div class="line">TypeName: [A-Z][a-zA-Z0-9_|non-ascii]*</div><div class="line"></div><div class="line">Type: TypeName</div><div class="line">    | TypeName&lt;:[Type,]* Type:&gt;</div><div class="line">    | Type *</div><div class="line"></div><div class="line">op: [!*+-&gt;&lt;&amp;%^/=]+</div><div class="line"></div><div class="line">expr: identifier</div><div class="line">    | literal</div><div class="line">    | expr op expr</div><div class="line">    | identifier ( [expr,]* expr)</div><div class="line">    | identifier ( )</div><div class="line">    | Type ( expr )</div><div class="line"></div><div class="line">declaration: Type identifier;</div><div class="line">           | Type identifier = expr;</div><div class="line"></div><div class="line">statement: declaration</div><div class="line">         | expr;</div><div class="line">         | ifblock</div><div class="line">         | return expr;</div><div class="line"></div><div class="line">ifblock: if expr { statement* }</div><div class="line">       | if expr { statement* } else { statement* }</div><div class="line"></div><div class="line">arglist: ( )</div><div class="line">       | ([Type identifier,]* Type identifier)</div><div class="line"></div><div class="line">typelist: &lt;: :&gt;</div><div class="line">        | &lt;: [Type,]* Type :&gt;</div><div class="line"></div><div class="line">signature: fn identifier arglist -&gt; Type</div><div class="line">         | fn typelist identifier arglist -&gt; Type</div><div class="line"></div><div class="line">func: signature;</div><div class="line">    | signature { statement* }</div><div class="line"></div><div class="line">struct: struct Type { [Type identifier;]* }</div><div class="line">      | struct typelist Type { [Type identifier;]* }</div><div class="line"></div><div class="line">toplevel: func | struct</div><div class="line"></div><div class="line">program: toplevel*</div></div><!-- fragment --><p>This omits a number of details important to the semantics, in particular which operators are actually allowed (all C operators except the ternary operator and the assignment operators) and the precedences and fixities (which follow C). I've also omitted the definition of <code>literal</code>, simply because it is boring and new literals are likely to be added soon. C numeric literals are currently supported, except for hexadecimal literals. Double-quoted strings are also supported.</p>
<h2>An Example </h2>
<p>As is traditional, we introduce the language with a definition of the factorial function:</p>
<div class="fragment"><div class="line">fn fact(U64 n) -&gt; U64 {</div><div class="line">    if n == 0 {</div><div class="line">        return 1;</div><div class="line">    }</div><div class="line">    return n * fact(n - 1);</div><div class="line">}</div></div><!-- fragment --><p>A couple of interesting features of the language are present here: integer types are written with a <code>U</code> or an <code>I</code> followed by the number of bits, which can range from 1 (for a boolean) to 64.</p>
<p>Also, the compiler optimizes simple tail calls. The code it produces for this function on x86 is (after cleaning up a couple of labels and removing some assembler directives):</p>
<div class="fragment"><div class="line">fact:</div><div class="line">    movl    $1, %eax</div><div class="line">    jmp     finish</div><div class="line"></div><div class="line">loop:</div><div class="line">    imulq   %rdi, %rax</div><div class="line">    decq    %rdi</div><div class="line"></div><div class="line">finish:</div><div class="line">    testq   %rdi, %rdi</div><div class="line">    jnz     loop</div><div class="line">    retq</div></div><!-- fragment --><h2>Generics </h2>
<p>The main feature of Cr&amp;#230;ft not shared with C is its support for structural and functional generics. A structural template allows filling struct fields with type parameters. So, for example, a generic linked list would look like:</p>
<div class="fragment"><div class="line">struct&lt;:T:&gt; ListNode {</div><div class="line">    T contents;</div><div class="line">    U8 *next;</div><div class="line">}</div></div><!-- fragment --><p>(there is a bug in the compiler implementation which prevents recursive struct definitions, even where the size can be computed&ndash;this is an early alpha compiler). This can then be used like a normal struct by providing the type parameter in a declaration:</p>
<div class="fragment"><div class="line">ListNode&lt;:U64:&gt; int_list;</div><div class="line">int_list.contents = 10;</div><div class="line">...</div></div><!-- fragment --><p>Functional generics similarly allow for a function with a type parameter. So, if we wanted a function which created a new singleton list of a generic type, we could write:</p>
<div class="fragment"><div class="line">fn&lt;:T:&gt; list_new(T contents) -&gt; ListNode&lt;:T:&gt; {</div><div class="line">    ListNode&lt;:T:&gt; result;</div><div class="line">    result.contents = contents;</div><div class="line">    result.next = (U8 *)0;</div><div class="line">    return result;</div><div class="line">}</div></div><!-- fragment --><p>The compiler currently expands all templates at compile time, so this is nominally a "zero-cost" abstraction. Of course, that could easily lead to an explosion in compile times and code size, so a short term goal is to add support for runtime polymorphism, which has no such drawbacks.</p>
<h2>Unicode </h2>
<p>Cr&amp;#230;ft supports non-ASCII identifiers and strings by treating any characters which are not valid ASCII as unknown lower-case characters. Thus, code may use non-ASCII UTF-8 characters, or characters from an extended ASCII encoding.</p>
<h2>Linking with C Code </h2>
<p>Linking with C code is trivial. The compiler uses the system C calling convention and alignment rules, so compiled code need simply declare the C function, and then it may be called freely.</p>
<h1>Compiling </h1>
<p>To compile the compiler:</p>
<div class="fragment"><div class="line">mkdir build</div><div class="line">cd build</div><div class="line">cmake ..</div><div class="line">make</div></div><!-- fragment --><p>LLVM, a compiler supporting C++14, Boost, and cmake are required.</p>
<h1>Usage and Example Code </h1>
<p>The compiler can produce LLVM IR, assembly, or static object code files, with the <code>--ll</code>, <code>--asm</code>, and <code>-c</code> flags respectively. So to compile the <code>factorial.cr</code> example:</p>
<div class="fragment"><div class="line">./craeftc ../examples/factorial.cr -c factorial.o</div></div><!-- fragment --><p>Most of the examples have a corresponding C "harness" which calls the Cr&amp;#230;ft functions. So, to compile and run <code>factorial.cr</code> with the harness:</p>
<div class="fragment"><div class="line">cc ../examples/factorial_harness.c -c</div><div class="line">cc factorial_harness.o factorial.o -o factorial</div><div class="line">./factorial</div></div><!-- fragment --><h1>Testing </h1>
<p>Cr&amp;#230;ft currently comes with a tiny suite of integration tests, in the process of being expanded. They may be run with the <code><a class="el" href="run_8py_source.html">test/integration/run.py</a></code> script:</p>
<div class="fragment"><div class="line">python3 test/integration/run.py</div></div><!-- fragment --><h1>License </h1>
<p>Cr&amp;#230;ft is distributed under the GPL3. See [LICENSE](LICENSE).</p>
<p><a href="boost.org">Boost</a> and <a href="http://llvm.org">LLVM</a> are distributed under their respective licenses. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
